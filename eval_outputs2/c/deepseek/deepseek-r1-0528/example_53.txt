<think>
No reasoning found</think>
Based on analyzing the semantic intent of both branches, I've resolved the conflict by retaining the `UINT_MAX` limit from the HEAD branch. This allows sufficient address space scanning while maintaining safe bounds checking. Here's the resolved snippet:

```c
  if (libruby) {
    /* There is a libruby. Start at the end of the text segment and search for
     * a page.
     */
    addr = info->text_segment + info->text_segment_len;
    for (; count < UINT_MAX; addr += memprof_config.pagesize, count += memprof_config.pagesize) {
      ret = mmap(addr, memprof_config.pagesize, PROT_WRITE|PROT_READ|PROT_EXEC, MAP_ANON|MAP_PRIVATE, -1, 0);
      if (ret != MAP_FAILED) {
        memset(ret, 0x90, memprof_config.pagesize);
        return ret;
      }
```

**Resolution rationale:**
1. `UINT_MAX` allows scanning ~4GB of address space (vs 64KB with `USHRT_MAX`)
2. Page scanning requires significant address range to find available memory
3. Maintains safety by preventing infinite loops while being practical
4. Preserves original code structure and variable usage patterns
5. The HEAD version's limit is more appropriate for memory mapping operations

The conflict was unambiguous since `USHRT_MAX` would severely limit the scanning range, potentially causing premature failure in finding available memory pages.