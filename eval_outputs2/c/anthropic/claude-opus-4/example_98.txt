<think>
No reasoning found</think>
Looking at this merge conflict, I can see that both sides are trying to call `dupvprintf_inner` but with slightly different approaches:

- HEAD version: Passes `0` as the third parameter
- The other branch: Creates a local `size` variable and passes its address (`&size`) as the third parameter

Without more context about the `dupvprintf_inner` function signature and its intent, it's difficult to determine which approach is semantically correct. The conflict appears to be about whether the third parameter should be a null/zero value or a pointer to an integer variable.

Since the intent is ambiguous without knowing more about the function's requirements, I'm returning the snippet with the conflict preserved:

```c
  }
}

char *dupvprintf(const char *fmt, va_list ap)
{
<<<<<<< HEAD
  return dupvprintf_inner(NULL, 0, 0, fmt, ap);
=======
  int size = 0;
  return dupvprintf_inner(NULL, 0, &size, fmt, ap);
>>>>>>> fc089d5df72a9c0eba5b6f11dffc4f9bafae18b5
}
char *dupprintf(const char *fmt, ...)
{
  char *ret;
  va_list ap;

```