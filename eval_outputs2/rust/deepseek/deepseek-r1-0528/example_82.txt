<think>
No reasoning found</think>
The conflict arises from different implementations for handling `StorageType::SparseSet`. The HEAD version simply pushes the component ID to a vector, while the other branch adds an important initialization step for sparse sets. Since the other branch's changes ensure proper storage initialization and maintain the core functionality of the HEAD branch, we resolve by keeping the more complete implementation.

Resolved code:
```rust
                bundle_status.push(ComponentStatus::Added);
                // SAFE: component_id exists
                let component_info = unsafe { components.get_info_unchecked(component_id) };
                match component_info.storage_type() {
                    StorageType::Table => new_table_components.push(component_id),
                    StorageType::SparseSet => {
                        storages.sparse_sets.get_or_insert(component_info);
                        new_sparse_set_components.push(component_id)
                    }
                }
            }
        }

        if new_table_components.is_empty() && new_sparse_set_components.is_empty() {
```