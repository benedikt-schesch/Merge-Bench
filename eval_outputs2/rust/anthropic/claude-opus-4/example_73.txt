<think>
No reasoning found</think>
Looking at this merge conflict, I need to analyze the semantic intent of both sides:

- HEAD version: Uses `T: Resource` as the type constraint
- Incoming version: Uses `T: Component` as the type constraint

This appears to be a refactoring where the codebase is transitioning from using `Component` to `Resource` (or vice versa). Given that this is for `OptionResMutState` which contains "Res" in its name (likely short for "Resource"), and the return type is `Option<ResMut<'w, T>>` (also containing "Res"), the semantic intent suggests this should be constrained by `Resource` rather than `Component`.

The HEAD version with `T: Resource` appears to be the semantically correct choice.

```rust
    }

    fn default_config() {}
}

impl<'w, 's, T: Resource> SystemParamFetch<'w, 's> for OptionResMutState<T> {
    type Item = Option<ResMut<'w, T>>;

    #[inline]
    unsafe fn get_param(
        state: &'s mut Self,

```