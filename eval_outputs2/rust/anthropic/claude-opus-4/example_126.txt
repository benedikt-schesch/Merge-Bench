<think>
No reasoning found</think>
Looking at this merge conflict, I can see that both sides are trying to initialize a `cache_map` HashMap, but there's also an additional `pending_removed_modules` vector initialization on the right side that needs to be preserved.

The semantic intent appears to be:
- Both sides want to create a HashMap for the cache
- The right side also needs to track modules that should be removed (via `pending_removed_modules`)
- The subsequent code clearly uses `pending_removed_modules` to collect expired modules

Here's the resolved code:

```rust

    None
  }

  fn write_cache(&self) {
    let mut cache_map = HashMap::new();
    let mut pending_removed_modules = vec![];
    for entry in self.cached_modules.iter() {
      let module = entry.value();
      if module.is_expired {
        pending_removed_modules.push(module.module.id.clone());
        continue;

```