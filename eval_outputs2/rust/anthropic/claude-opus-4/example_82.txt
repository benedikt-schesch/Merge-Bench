<think>
No reasoning found</think>
Looking at this merge conflict, I need to understand what each side is trying to achieve:

- **HEAD (left side)**: Simply pushes the component_id to new_sparse_set_components
- **Right side**: Additionally calls `storages.sparse_sets.get_or_insert(component_info)` before pushing the component_id

The semantic intent appears to be that the right side is ensuring that the sparse set storage is properly initialized/registered before adding the component. This is likely a necessary step that was added to fix a bug or ensure proper initialization.

Since both sides want to push to new_sparse_set_components, and the right side adds what appears to be a necessary initialization step, the resolution should keep the right side's changes:

```rust
                bundle_status.push(ComponentStatus::Added);
                // SAFE: component_id exists
                let component_info = unsafe { components.get_info_unchecked(component_id) };
                match component_info.storage_type() {
                    StorageType::Table => new_table_components.push(component_id),
                    StorageType::SparseSet => {
                        storages.sparse_sets.get_or_insert(component_info);
                        new_sparse_set_components.push(component_id)
                    }
                }
            }
        }

        if new_table_components.is_empty() && new_sparse_set_components.is_empty() {

```