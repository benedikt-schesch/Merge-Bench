<think>
No reasoning found</think>
Looking at this merge conflict, I need to understand what both sides are trying to achieve:

- The HEAD side adds an early return optimization: if the types are already equal, no substitution is needed, so return `None`.
- The other side (b84bd19237cd84a89ca508bc4f415dabaff8da77) removes this check entirely.

The semantic intent appears to be about whether to include an equality check before performing type parameter substitution. The HEAD side wants to optimize by avoiding unnecessary work when types are already equal, while the other side seems to want to proceed with the substitution logic even for equal types.

Without more context about why the check was removed in the other branch, it's ambiguous whether:
1. The equality check was causing issues and needed to be removed
2. The removal was accidental
3. There's a semantic reason why substitution should proceed even for equal types

Since the intent is ambiguous, I'm returning the snippet with the conflict preserved:

```rust
    pub(crate) fn substitute_typarams(
        ctx: &'c Context,
        qt: &Type,
        st: &Type,
    ) -> EvalResult<Option<Self>> {
<<<<<<< HEAD
        if qt == st {
            return Ok(None);
        }
=======
>>>>>>> b84bd19237cd84a89ca508bc4f415dabaff8da77
        let mut qtps = qt.typarams();
        let mut stps = st.typarams();
        // Or, And are commutative, choose fitting order
        if qt.qual_name() == st.qual_name() {
            if st.is_union_type() || st.is_intersection_type() {
```