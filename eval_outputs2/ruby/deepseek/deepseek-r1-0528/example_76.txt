<think>
No reasoning found</think>
I've analyzed the semantic merge conflict. The key issue is that the incoming branch refactored the code to pass the `node_manager` instance to `trap_signals` instead of relying on an instance variable. This is more explicit and avoids class-level state. Here's the resolved version:

```ruby
    # @param [Array] options the command-line options
    # @note this method blocks and does not return until the
    #   Node Manager is gracefully stopped
    def self.run(options)
      options = CLI.parse(options)
      node_manager = NodeManager.new(options)
      trap_signals(node_manager)
      node_manager.start
    end

    # Traps shutdown signals.
    # @param [NodeManager] node_manager the node manager
    def self.trap_signals(node_manager)
```

Reasoning:
1. The `trap_signals` method now requires a parameter (as shown in the method definition)
2. Using a local variable (`node_manager`) is sufficient since it's only used within the `run` method
3. This maintains the incoming branch's explicit dependency injection approach
4. The instance variable (`@node_manager`) isn't necessary since there's no further class-level usage shown in the context
5. The semantics of both branches are preserved (initialization, signal trapping, and startup)

The conflict is resolved by using the incoming branch's implementation since it satisfies the new method signature while maintaining the original intent of both branches.