<think>
No reasoning found</think>
The conflict arises from two different modifications to the `add_attribute` method. The HEAD branch adds a line to convert the `name` parameter to a symbol, while the other branch adds a validation to prevent attribute names ending with `=`. These changes are compatible when combined in the correct order. 

The resolution:
1. First, validate the attribute name doesn't end with `=` (from the other branch)
2. Then convert the name to a symbol (from HEAD branch)
3. Maintain the rest of the method logic

This preserves both intents:
- Prevents setter-style attributes
- Ensures consistent symbol usage for attribute names

Resolved code:
```ruby
  #     The name of this attribute. This will be assigned using :"#{name}=" for
  #     generated instances.
  #   value: (Object)
  #     If no block is given, this value will be used for this attribute.
  def add_attribute (name, value = nil, &block)
    if name.to_s =~ /=$/
      raise AttributeDefinitionError, "factory_girl uses 'f.#{name.to_s.chop} #{value}' syntax rather than 'f.#{name} #{value}'" 
    end
    
    name = name.to_sym

    if block_given?
      unless value.nil?
        raise ArgumentError, "Both value and block given"
      end
      @lazy_attribute_blocks[name] = block
```