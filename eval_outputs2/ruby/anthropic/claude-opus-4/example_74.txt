<think>
No reasoning found</think>
Looking at this merge conflict, I need to understand what both sides are trying to achieve:

**HEAD side:**
- Checks if `@master_manager` exists before proceeding
- Gets the new master from `manual_failover_path` method with a watch

**Other side:**
- Checks if `@leader` exists before proceeding
- Gets the new master from `@manual_znode` instance variable with a watch
- Adds an additional check to ensure `new_master` exists and has content

The semantic intent appears to be:
1. Both sides want to guard the execution (one checks `@master_manager`, the other `@leader`)
2. Both sides want to get the new master value from ZooKeeper with a watch
3. The other side adds an extra validation to ensure the retrieved value is valid

The conflict seems to be about:
- Which guard variable to use (`@master_manager` vs `@leader`)
- Which path to use (`manual_failover_path` vs `@manual_znode`)
- Whether to include the additional validation

Since I cannot determine the correct intent without more context about which variable names and approaches are correct for this codebase, I'll return the snippet with the conflict preserved:

```ruby
      @zk.set(path, value)
    end

    # Schedules a manual failover to a redis node.
    def schedule_manual_failover
<<<<<<< HEAD
      return unless @master_manager
      new_master = @zk.get(manual_failover_path, :watch => true).first
=======
      return unless @leader
      new_master = @zk.get(@manual_znode, :watch => true).first
      return unless new_master && new_master.size > 0
>>>>>>> 7078cc41f591768dc824c82efbbf1c7653a45e30
      logger.info("Received manual failover request for: #{new_master}")
      logger.info("Current nodes: #{current_nodes.inspect}")

      node = if new_master == ManualFailover::ANY_SLAVE
        @slaves.shuffle.first
```