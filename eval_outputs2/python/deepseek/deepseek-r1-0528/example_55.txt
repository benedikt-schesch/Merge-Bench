<think>
No reasoning found</think>
The conflict arises from two different approaches to testing exception handling. Both sides aim to validate that an invalid frozenset raises a `MultipleInvalid` exception with the message "invalid value in frozenset", but they differ in their verification approach.

The resolution combines both intents:
1. Uses `pytest.raises` context manager to capture the exception (common to both)
2. Maintains the `match` parameter to validate the exception message (from HEAD)
3. Adds the assertion for exactly 1 error (from branch)
4. Removes redundant try/except blocks since `pytest.raises` already handles exception capture

Resolved code:
```python
    schema(frozenset([42]))
    schema(frozenset([42, 43, 44]))

    with pytest.raises(MultipleInvalid, match="invalid value in frozenset") as ctx:
        schema(frozenset(['abc']))
    assert len(ctx.value.errors) == 1


def test_set_of_integers_and_strings():
    schema = Schema({int, str})
    with raises(Invalid, 'expected a set'):

```