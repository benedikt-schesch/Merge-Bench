<think>
No reasoning found</think>
Here's the resolved code snippet, preserving the context and spacing while resolving the conflict based on semantic intent. Both versions of the code achieved the same functionality (conditional assignment with fallback), so I selected the more idiomatic Python style from the changes:

```python
            else:
                result[key] = value

        # recompile and send old object
        result_cls = type(self)
        result_required = required if required is not None else self.required
        result_extra = extra if extra is not None else self.extra
        return result_cls(result, required=result_required, extra=result_extra)


def _compile_scalar(schema):
    """A scalar value.
```

**Resolution reasoning:**  
1. Both conflict versions implement identical logic - choose new parameters if provided, else keep existing instance values
2. The version without redundant parentheses (`required if ... else ...`) is more Pythonic and matches common style conventions
3. Parentheses don't change functionality here but add unnecessary visual noise
4. Preserves surrounding context exactly as provided
5. Maintains consistency with the codebase's existing 4-space indentation

The resolution maintains the semantic intent of both branches while removing superfluous syntax.