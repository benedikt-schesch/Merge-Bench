<think>
No reasoning found</think>
To resolve this merge conflict, we need to analyze the intent behind the changes made on both sides of the merge.

The code snippet is written in Java and appears to be part of a utility class for creating a KeyStore for mutual TLS (Transport Layer Security). The method `createMtlsKeyStore` takes an `InputStream` containing a certificate and a private key, and returns a `KeyStore` instance.

The merge conflict arises from the presence of the `@Beta` annotation on one side of the merge (HEAD) and its absence on the other side (51762f221ec8ab38da03149c8012e63aec0433dc).

The `@Beta` annotation typically indicates that the annotated class or method is in a state of flux and might change or be removed in the future. Its presence suggests that the `createMtlsKeyStore` method is not considered stable or final.

To resolve the conflict, we need to consider the intent behind adding or removing the `@Beta` annotation.

1. If the intent is to mark the `createMtlsKeyStore` method as stable and ready for use, removing the `@Beta` annotation (as done on the 51762f221ec8ab38da03149c8012e63aec0433dc side) would be the correct choice.
2. If the intent is to indicate that the method is still evolving or not finalized, keeping the `@Beta` annotation (as on the HEAD side) is appropriate.

Without additional context on the development stage or the reasoning behind adding/removing the `@Beta` annotation, it's challenging to definitively resolve the conflict based solely on the provided code snippet.

However, given the information available, the most straightforward resolution that doesn't alter the surrounding context or spacing is to decide based on the semantic intent. Since we can't deduce the exact intent without more context, the conflict should be returned as is.

Here is the code snippet with the conflict, preserved in markdown code syntax:

```java
   * @param certAndKey Certificate and private key input stream. The stream should contain one
   *     certificate and one unencrypted private key. If there are multiple certificates, only the
   *     first certificate will be used.
   * @return keystore for mutual TLS.
   */
<<<<<<< HEAD
  @Beta
=======
>>>>>>> 51762f221ec8ab38da03149c8012e63aec0433dc
  public static KeyStore createMtlsKeyStore(InputStream certAndKey)
      throws GeneralSecurityException, IOException {
    KeyStore keystore = KeyStore.getInstance("JKS");
    keystore.load(null);
```