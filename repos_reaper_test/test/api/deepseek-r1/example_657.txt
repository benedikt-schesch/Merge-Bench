<think>
Okay, let's look at this merge conflict. The code has an import statement for java.io.IOException, and then there's a conflict between the HEAD version which adds an import for java.util.Map and the other branch which doesn't have that. 

So the question is whether the java.util.Map import is needed here. Looking at the surrounding context, the class is a WebRequestor implementation that loads a file from the classpath. The original HEAD added Map, maybe because it's used somewhere in the code. But the other branch doesn't have that import. 

Wait, the code snippet provided doesn't show any usage of Map in the surrounding lines. The imports are static, and then the class comment. Maybe the import for Map was added in HEAD but the other branch didn't have it. If the resolved code should include both, but since the conflict is on the import line, we need to check if both are necessary.

But since the conflict is between adding Map and not, perhaps in HEAD they started using Map in the class, and the other branch didn't. If the final code requires Map, then we should keep the import. However, if the other branch's changes don't touch that import, maybe it's a conflict where one side added it and the other didn't. 

But the user said to resolve semantically. If both changes don't affect each other, maybe the correct resolution is to include both. Wait, the conflict is between the HEAD adding the import and the other branch not having it. So if the import is needed, we keep it. But without seeing the rest of the code, it's hard to tell. But since the user wants a semantic resolution, perhaps the Map import is necessary in the HEAD version, and the other branch didn't remove it. So the correct resolution is to keep the Map import. Therefore, the conflict markers should be removed, keeping the HEAD's line with java.util.Map.</think>
```java

import static com.restfb.util.StringUtils.fromInputStream;
import static java.net.HttpURLConnection.HTTP_OK;

import java.io.IOException;
import java.util.Map;

/**
 * {@link WebRequestor} implementation that loads a file from the classpath instead of hitting the web. Useful for
 * running unit tests against local JSON textfiles.
 * 
```