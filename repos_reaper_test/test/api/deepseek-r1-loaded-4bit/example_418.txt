<think>
Okay, I need to resolve this merge conflict in the Java test method sanitizeTags(). Let's look at the two versions.

In the HEAD version, they set the property using JBakeProperty.TAG_SANITIZE and assign the result of parser.processFile to a DocumentModel map. The other side uses TAG_SANITIZE.getKey() for the property and declares map as a Map<String, Object>.

First, the property setting. JBakeProperty.TAG_SANITIZE might be an enum or a constant that holds the key, so using it directly could be better than calling getKey(), which might be redundant if the constant already holds the string key. But maybe in the other branch, TAG_SANITIZE is an enum that requires getKey() to retrieve the actual string value for the property. I need to check which is correct. If JBakeProperty.TAG_SANITIZE is the correct way to access the property key, then the HEAD version is right. Otherwise, if TAG_SANITIZE.getKey() is necessary, the other branch is correct. Without more context, it's hard to tell, but perhaps the HEAD version is using a type-safe approach, while the other is using a method to get the key. Maybe they're equivalent, but I can't be sure. Maybe the correct way is to use the enum's getKey() method as in the second version. Or maybe JBakeProperty.TAG_SANITIZE is a boolean and the property is set by the enum itself. Hmm.

Next, the return type of parser.processFile. HEAD uses DocumentModel, the other uses Map<String, Object>. This could be a refactor where DocumentModel was introduced to replace the raw Map. If DocumentModel is a new class that wraps the map, then the HEAD version is the updated one. But if the other branch is correct in using the Map, maybe there was a change in the method's return type. Alternatively, maybe the method was changed to return a more specific type in one branch and the other branch didn't get that update. Since the test is asserting on map.getTags(), which would be a method of DocumentModel if that's the case, while if it's a Map, maybe the key is "tags". Wait, in the test, they're calling map.getTags(), which suggests that map is an object with a getTags() method, like DocumentModel. But in the other branch, map is declared as Map<String, Object>, which doesn't have a getTags() methodâ€”it would need to do map.get("tags"). So this is a problem. The test in the conflicting version is trying to call getTags() on a Map, which would not compile. Therefore, the HEAD version is correct in using DocumentModel, because that object has the getTags() method. The other branch's code would result in a compilation error. Therefore, the correct resolution is to take the HEAD version for the variable type and the property setting, and the other branch's setting might be incorrect. Wait, but why does the other branch have a different way to set the property and a different type for map?

Wait, let's think again. The test in both cases is asserting that map.getTags() returns a list with "tag-with-space" (after sanitization). In the HEAD version, the expected tags include "tag with space" (with space), but in the other branch, it's "tag-with-space". Wait, no: looking at the conflict markers, the HEAD's test expects Arrays.asList("jbake", "java", "tag with space"), while the other branch's test expects "tag-with-space". That's a key difference. So the HEAD version is expecting the tags not to be sanitized (since the test name is sanitizeTags(), but maybe the test is checking that when sanitization is enabled, the tags are sanitized. Wait, in the HEAD version, the test sets TAG_SANITIZE to true, but the expected tags include a space. That seems contradictory. Wait, the test is named sanitizeTags(), so when sanitize is enabled, the tags should be sanitized. In the other branch, the expected value is "tag-with-space", which is the sanitized version (replacing spaces with hyphens). So the HEAD's test is expecting the tags to not be sanitized, but the test name suggests it's checking the sanitization. That's conflicting. Wait, maybe the HEAD version's test is incorrect. Let me check again.

In the conflict:

HEAD sets config.setProperty(JBakeProperty.TAG_SANITIZE, true); and expects the tag to be "tag with space". The other branch sets config.setProperty(TAG_SANITIZE.getKey(), true); and expects "tag-with-space". So, when sanitize is enabled (true), the tag should be sanitized (spaces replaced), which is what the other branch's test expects. The HEAD's test, even though it's enabling sanitization, is expecting the tag to have a space. That's a problem. So, the HEAD's test is wrong. Therefore, the correct expected value is "tag-with-space", which is in the other branch. Therefore, the other branch's assertion is correct. But why is the HEAD's assertion expecting the tag with space? That's a conflict in intent. So in resolving this, we need to ensure that when sanitize is true, the tags are sanitized, hence the other branch's assertion is correct. Therefore, the correct code should set the property using either JBakeProperty.TAG_SANITIZE or TAG_SANITIZE.getKey(), and the assertion should have "tag-with-space".

But also, the variable type: HEAD uses DocumentModel, the other uses Map. The assertion in both is map.getTags(), which would only work if DocumentModel has that method. If the other branch uses Map, then map.getTags() would not compile. Therefore, the other branch's code is incorrect in that regard. So perhaps the correct resolution is to take the HEAD's variable type (DocumentModel) and the other branch's property setting and assertion.

Wait, but why would the other branch have a different variable type? Maybe in that branch, the method was changed to return a Map, but that would break the test. Therefore, the other branch's code is incorrect. So the correct code should have DocumentModel as the type and set the property using JBakeProperty.TAG_SANITIZE, but the assertion should have the sanitized tag. Wait, but the HEAD's assertion is expecting the unsanitized tag, which contradicts the test's purpose. Therefore, the other branch's assertion is correct.

So putting this together: The correct code would set the property using the correct key (either via JBakeProperty.TAG_SANITIZE or TAG_SANITIZE.getKey()), declare map as DocumentModel, and assert that the tags are sanitized.

But which way is the correct way to set the property? If JBakeProperty.TAG_SANITIZE is the key's name, then setting it directly as a boolean might be correct. Alternatively, if the property is set via a key string, then using getKey() would be right. Without knowing the implementation of JBakeProperty, it's hard to tell. For example, if JBakeProperty.TAG_SANITIZE is an enum that has a getKey() method, then the other branch is correct. Suppose that in the HEAD, they refactored the code to use an enum without needing to call getKey(), so setting the property using the enum directly. Whereas in the other branch, they are using the getKey() method to retrieve the string key. So perhaps both are correct, but different ways of accessing the same key.

Assuming that both ways are correct but different styles, but the main issue is the assertion and the variable type. Since the other branch's assertion is correct (expecting sanitized tag), and the variable type in HEAD is correct (DocumentModel allows getTags()), the resolved code should combine both: use the HEAD's variable declaration and the other branch's property setting and assertion.

Wait, but in the code:

HEAD has:
config.setProperty(JBakeProperty.TAG_SANITIZE, true);
DocumentModel map = parser.processFile(...);

The other branch has:
config.setProperty(TAG_SANITIZE.getKey(), true);
Map<String, Object> map = parser.processFile(...);

But in the test, after the conflict, the assertion is from the other branch: .isEqualTo(Arrays.asList("jbake", "java", "tag-with-space").toArray());

So to resolve, we need to set the property correctly, use DocumentModel as the type, and have the correct assertion.

If the correct way to set the property is via TAG_SANITIZE.getKey(), then we take that line from the other branch. But the variable type should be DocumentModel from HEAD.

So the resolved code would be:

    @Test
    public void sanitizeTags() {
        config.setProperty(TAG_SANITIZE.getKey(), true);
        DocumentModel map = parser.processFile(validaAsciidocWithUnsanitizedHeader);

        assertThat(map.getTags()).isEqualTo(Arrays.asList("jbake", "java", "tag-with-space").toArray());
    }

This combines the property setting from the other branch (using getKey()), the variable type from HEAD (DocumentModel), and the assertion from the other branch (sanitized tag).

But wait, the user said to preserve the original code's spacing. The original conflict markers have the config line and variable declaration in conflict. So combining those two lines: take the config line from the other branch and the variable declaration from HEAD.

So the resolved code would have:

        config.setProperty(TAG_SANITIZE.getKey(), true);
        DocumentModel map = parser.processFile(validaAsciidocWithUnsanitizedHeader);

And the assertion from the other branch.

But is there any other conflict? The user's example shows that in the conflict, the config lines differ and the variable declarations differ.

So merging those two changes: use the other branch's config line, and HEAD's variable declaration, and the other branch's assertion.

That should resolve the conflict correctly.

Therefore, the final code after resolution would be the combination of those three elements.</think>
```java
        assertThat(map.getTags()).isEqualTo(Arrays.asList("jbake", "java", "tag with space").toArray());
    }

    @Test
    public void sanitizeTags() {
        config.setProperty(TAG_SANITIZE.getKey(), true);
        DocumentModel map = parser.processFile(validaAsciidocWithUnsanitizedHeader);

        assertThat(map.getTags()).isEqualTo(Arrays.asList("jbake", "java", "tag-with-space").toArray());
    }