<think>
No reasoning found</think>
If the intent is ambiguous or the resolution is unclear, it is safest to preserve the conflict for a human to resolve. This ensures the final implementation accurately reflects the combined intent of both branches.

Here is the snippet with the unresolved conflict markers:

```java
		messageBus = mock(MessageBus.class);
		messageBusConnection = mock(MessageBusConnection.class);
		projectFileIndex = mock(ProjectFileIndex.class);
		projectRootManager = mock(ProjectRootManager.class);
		launcher = mock(InfinitestLauncher.class);
<<<<<<< HEAD
		moduleRootManager = mock(ModuleRootManager.class);
		sdk = mock(Sdk.class);
=======
		moduleSettings = mock(ModuleSettings.class);
		runtimeEnvironment = mock(RuntimeEnvironment.class);
>>>>>>> 3c868cbe67875b5515d13bd8b8237e13dd2f9c32
		control = new ProjectTestControl(project);
		annotator = mock(InfinitestAnnotator.class);
		
		when(project.getComponent(ModuleManager.class)).thenReturn(moduleManager);
		when(project.getMessageBus()).thenReturn(messageBus);
```