<think>
No reasoning found</think>
The code snippet shows a HashMap being initialized with explicit type parameters on one side and without type parameters on the other. The left side uses	type safety with generics, which helps prevent unchecked operations and potential warning messages.

```
      synchronized (roundPlayers) {
        for (final Player player : roundPlayers) {
          final List<WhiteCard> cards = playedCards.getCards(player);
          if (cards == null || cards.size() < blackCard.getPick()) {
<<<<<<< HEAD
            final Map<ReturnableData, Object> data = new HashMap<ReturnableData, Object>();
=======
            final Map<ReturnableData, Object> data = new HashMap<>();
>>>>>>> 5adedd24812861bedaf540555ec046744b42b42a
            data.put(LongPollResponse.EVENT, LongPollResponse.HURRY_UP.toString());
            data.put(LongPollResponse.GAME_ID, this.id);
            final QueuedMessage q = new QueuedMessage(MessageType.GAME_EVENT, data);
            player.getUser().enqueueMessage(q);
          }
```