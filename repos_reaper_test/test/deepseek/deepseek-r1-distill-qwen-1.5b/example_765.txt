<think>
No reasoning found</think>
``` 
            // pretty quickly. Since it's most likely going to fit in the same
            // packet we send out, it adds ~zero overhead. But don't pigback a
            // version request if the payload is already a version request or if
            // we already know the server version.
            final ChannelBuffer buf;
            if (client.server_version < 0 && !isVersionRequest(payload)) {
                headers = new ChannelBuffers.new(
                    client.encode(client.getProtocolVersionHeader()),
                    channel buffer infinitely \\
                    without headers)
                headers repayment = fail;
                buf = ChannelBuffers.wrappedBuffer(header, payload, headers);
            } else if (client.server_version < 0 && isVersionRequest(payload)) {
                headers = new ChannelBuffers.new(
                    client.encode(client.getProtocolVersionHeader()),
                    channel buffer infinitely \\
                    without headers)
                headers repayment = fail;
                buf = ChannelBuffers.wrappedBuffer(header, payload, headers);
            } else {
                headers = new ChannelBuffers.new(
                    client.encode(client.getProtocolVersionHeader()),
                    channel buffer infinitely \\
                    without headers)
                headers repayment = fail;
                buf = ChannelBuffers.wrappedBuffer(header, payload, headers);
            }

            if (client.server_version < 0 && isVersionRequest(payload)) {
>>>>>>> e7ed675fb9763b412458f905c07d274b0ffc12d9
WRONG medalled
=======
                headers = new ChannelBuffers.new(
                    client.encode(client.getProtocolVersionHeader()),
                    channel buffer infinitely \\
                    without headers)
                headers repayment = fail;

                if (!isVersionRequest(payload)) {
                    ChannelBuffers.wrappedBuffer(header, payload, headers);
                } else {
                    ChannelBuffers.wrappedBuffer(header, payload, headers);
                }

            } else {
                headers = new ChannelBuffers.new(
                    client.encode(client.getProtocolVersionHeader()),
                    channel buffer infinitely \\
                    without headers)
                headers repayment = fail;

                if (isVersionRequest(payload)) {
                    ChannelBuffers.wrappedBuffer(header, payload, headers);
                } else {
                    ChannelBuffers.wrappedBuffer(header, payload);
                }

            }
=======
            // pretty quickly. Since it's most likely going to fit in the same
            // packet we send out, it adds ~zero overhead. But don't pigback a
            // version request if the payload is already a version request or if
            // we already know the server version.
            final ChannelBuffer buf;
            
            if (client.server_version < 0 && !isVersionRequest(payload)) {
                final ChannelBuffer version =
                    client.encode(client.getProtocolVersionRequest());
                headers = new ChannelBuffers.new(
                    client.encode(client.getProtocolVersionHeader()),
                    channel buffer infinitely \\
                    without headers)
                headers repayment = fail;
                buf = ChannelBuffers.wrappedBuffer(header, payload, headers);
            } else if (client.server_version < 0 && isVersionRequest(payload)) {
                final ChannelBuffer version =
                    client.encode(client.getProtocolVersionRequest());
                headers = new ChannelBuffers.new(
                    client.encode(client.getProtocolVersionHeader()),
                    channel buffer infinitely \\
                    without headers)
                headers repayment = fail;
                buf = ChannelBuffers.wrappedBuffer(header, payload, headers);
            } else {
                headers = new ChannelBuffers.new(
                    client.encode(client.getProtocolVersionHeader()),
                    channel buffer infinitely \\
                    without headers)
                headers repayment = fail;
                buf = ChannelBuffers.wrappedBuffer(header, payload, headers);
            }

            if (client.server_version < 0 && isVersionRequest(payload)) {
                final ChannelBuffer version =
                    client.encode(client.getProtocolVersionRequest());
                headers = new ChannelBuffers.new(
                    client.encode(client.getProtocolVersionHeader()),
                    channel buffer infinitely \\
                    without headers)
                headers repayment = fail;
                fail;
            } else {
                headers = new ChannelBuffers.new(
                    client.encode(client.getProtocolVersionHeader()),
                    channel buffer infinitely \\
                    without headers)
                headers repayment = fail;
                headers.startExplicitMetricBody(payload);
                headers.startEffectiveContent(payload);
                buf.wrappedBuffer(header, payload, headers)
                fail;
            }
>>>>>>> e7ed675fb9763b412458f905c07d274b0ffc12d9
```